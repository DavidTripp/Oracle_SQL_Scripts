SELECT NULL SAMPLE_TIME, NULL INST, NULL SID, NULL PROGRAM, NULL ACTION, NULL SQL_ID
FROM DUAL WHERE 1 = 0
UNION ALL (
SELECT NULL SAMPLE_TIME, NULL INST, NULL SID, NULL PROGRAM, NULL ACTION, NULL SQL_ID
FROM DUAL WHERE 1 = 0
) UNION ALL ( SELECT * FROM (
WITH BASIS_INFO AS
( SELECT /*+ INLINE */  /* hint sometimes required to push SNAP_IDs into DBA_HIST_ACTIVE_SESS_HISTORY */
    DECODE(DBID, -1, OWN_DBID, DBID) DBID,
    DECODE(INSTANCE_NUMBER, -1, USERENV('INSTANCE'), INSTANCE_NUMBER) INSTANCE_NUMBER,
    BEGIN_DATE,
    END_DATE,
    TO_TIMESTAMP(TO_CHAR(BEGIN_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') BEGIN_TIME,
    TO_TIMESTAMP(TO_CHAR(END_DATE, 'dd.mm.yyyy hh24:mi:ss'), 
      'dd.mm.yyyy hh24:mi:ss') END_TIME,
    BEGIN_SNAP_ID,    
    END_SNAP_ID,
    SQL_ID,
    DATA_SOURCE
  FROM
  ( SELECT
      -1 DBID,
      -2 INSTANCE_NUMBER,
      TO_DATE('01.01.1000 00:05:00', 'dd.mm.yyyy hh24:mi:ss') BEGIN_DATE,
      TO_DATE('31.12.9999 07:50:00', 'dd.mm.yyyy hh24:mi:ss') END_DATE,
      -1 BEGIN_SNAP_ID,   /* explicit SNAP_IDs sometimes required for ASH partition pruning */
      -1 END_SNAP_ID,
      '%' SQL_ID,
      'AWR' DATA_SOURCE           /* AWR, CURRENT */
    FROM
      DUAL
  ),
  ( SELECT DBID OWN_DBID FROM V$DATABASE )
),
SNAPSHOTS AS
( SELECT 
    HSS.DBID,
    HSS.INSTANCE_NUMBER,
    MIN(HSS.SNAP_ID) BEGIN_SNAP_ID,
    MIN(HSS.BEGIN_INTERVAL_TIME) BEGIN_TIME,
    MAX(HSS.SNAP_ID) END_SNAP_ID,
    MAX(HSS.END_INTERVAL_TIME) END_TIME
  FROM 
    DBA_HIST_SNAPSHOT HSS,
    BASIS_INFO BI
  WHERE
    HSS.DBID = BI.DBID AND
    HSS.END_INTERVAL_TIME >= BI.BEGIN_TIME AND
    HSS.BEGIN_INTERVAL_TIME <= BI.END_TIME AND
    ( BI.BEGIN_SNAP_ID = -1 OR
      HSS.SNAP_ID >= BI.BEGIN_SNAP_ID ) AND 
    ( BI.END_SNAP_ID = -1 OR
      HSS.SNAP_ID <= BI.END_SNAP_ID ) AND
    ( BI.INSTANCE_NUMBER = -2 OR
      HSS.INSTANCE_NUMBER = BI.INSTANCE_NUMBER )
  GROUP BY
    HSS.DBID,
    HSS.INSTANCE_NUMBER
),
PX_SLAVES AS 
( SELECT /*+ MATERIALIZE */ 
    ASH.SAMPLE_TIME,
    ASH.SAMPLE_ID,
    ASH.INST_ID INSTANCE_NUMBER,
    ASH.SESSION_ID,
    ASH.QC_INSTANCE_ID,
    ASH.QC_SESSION_ID,
    DECODE(ASH.SESSION_STATE, 'WAITING', ASH.EVENT, 'CPU') ACTION,
    ASH.PROGRAM,
    ASH.SQL_ID
  FROM 
    BASIS_INFO BI,
    GV$ACTIVE_SESSION_HISTORY ASH
  WHERE
    ( BI.INSTANCE_NUMBER = -2 OR BI.INSTANCE_NUMBER = ASH.INST_ID ) AND
    ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
    BI.DATA_SOURCE = 'CURRENT' AND
    ASH.QC_SESSION_ID IS NOT NULL AND
    ( ASH.QC_SESSION_ID != ASH.SESSION_ID OR ASH.QC_INSTANCE_ID != ASH.INST_ID )
  UNION ALL
  ( SELECT 
      ASH.SAMPLE_TIME,
      ASH.SAMPLE_ID,
      ASH.INSTANCE_NUMBER,
      ASH.SESSION_ID, 
      ASH.QC_INSTANCE_ID,
      ASH.QC_SESSION_ID,
      DECODE(ASH.SESSION_STATE, 'WAITING', ASH.EVENT, 'CPU') ACTION,
      ASH.PROGRAM,
      ASH.SQL_ID
    FROM 
      BASIS_INFO BI,
      SNAPSHOTS SS,
      DBA_HIST_ACTIVE_SESS_HISTORY ASH
    WHERE
      ASH.DBID = BI.DBID AND
      ( BI.INSTANCE_NUMBER = -2 OR BI.INSTANCE_NUMBER = ASH.INSTANCE_NUMBER ) AND
      ASH.SNAP_ID BETWEEN SS.BEGIN_SNAP_ID AND SS.END_SNAP_ID AND
      ASH.SAMPLE_TIME BETWEEN BI.BEGIN_TIME AND BI.END_TIME AND
      BI.DATA_SOURCE = 'AWR' AND
      ASH.QC_SESSION_ID IS NOT NULL AND
    ( ASH.QC_SESSION_ID != ASH.SESSION_ID OR ASH.QC_INSTANCE_ID != ASH.INSTANCE_NUMBER )
  )
),
PX_COORDINATORS AS
( SELECT /*+ MATERIALIZE */
    BS.SAMPLE_TIME,
    BS.SAMPLE_ID,
    BS.QC_INSTANCE_ID INSTANCE_NUMBER,
    BS.QC_SESSION_ID SESSION_ID,
    CASE WHEN ASH.SESSION_ID = ASH.QC_SESSION_ID AND ASH.INST_ID = ASH.QC_INSTANCE_ID THEN 
      NULL ELSE ASH.QC_INSTANCE_ID END QC_INSTANCE_ID,
    CASE WHEN ASH.SESSION_ID = ASH.QC_SESSION_ID AND ASH.INST_ID = ASH.QC_INSTANCE_ID THEN 
      NULL ELSE ASH.QC_SESSION_ID END QC_SESSION_ID,
    DECODE(ASH.SESSION_STATE, NULL, 'INACTIVE', 'WAITING', ASH.EVENT, 'CPU') ACTION,
    ASH.PROGRAM,
    ASH.SQL_ID
  FROM
    BASIS_INFO BI,
    PX_SLAVES BS,
    GV$ACTIVE_SESSION_HISTORY ASH
  WHERE
    BS.SAMPLE_TIME = ASH.SAMPLE_TIME (+) AND
    BS.QC_SESSION_ID = ASH.SESSION_ID (+) AND
    BS.QC_INSTANCE_ID = ASH.INST_ID (+) AND
    BI.DATA_SOURCE = 'CURRENT'
  UNION
  ( SELECT
      BS.SAMPLE_TIME,
      BS.SAMPLE_ID,
      BS.QC_INSTANCE_ID INSTANCE_NUMBER,
      BS.QC_SESSION_ID SESSION_ID,
      CASE WHEN ASH.SESSION_ID = ASH.QC_SESSION_ID AND ASH.INSTANCE_NUMBER = ASH.QC_INSTANCE_ID THEN 
        NULL ELSE ASH.QC_INSTANCE_ID END QC_INSTANCE_ID,
      CASE WHEN ASH.SESSION_ID = ASH.QC_SESSION_ID AND ASH.INSTANCE_NUMBER = ASH.QC_INSTANCE_ID THEN 
        NULL ELSE ASH.QC_SESSION_ID END QC_SESSION_ID,
      DECODE(ASH.SESSION_STATE, NULL, 'INACTIVE', 'WAITING', ASH.EVENT, 'CPU') ACTION,
      ASH.PROGRAM,
      ASH.SQL_ID
    FROM
      BASIS_INFO BI,
      SNAPSHOTS SS,
      PX_SLAVES BS,
      DBA_HIST_ACTIVE_SESS_HISTORY ASH
    WHERE
      BS.SAMPLE_TIME = ASH.SAMPLE_TIME (+) AND
      BS.QC_SESSION_ID = ASH.SESSION_ID (+) AND
      BS.QC_INSTANCE_ID = ASH.INSTANCE_NUMBER (+) AND
      BI.DATA_SOURCE = 'AWR'
  )
),
ALL_RELEVANT_SESSIONS AS
( SELECT
    *
  FROM
    PX_SLAVES
  UNION
  ( SELECT
      *
    FROM
      PX_COORDINATORS
  )
),
RELEVANT_SAMPLE_TIMES AS
( SELECT DISTINCT
    S.SAMPLE_TIME,
    S.SAMPLE_ID
  FROM
    BASIS_INFO BI,
    ALL_RELEVANT_SESSIONS S
  WHERE
    NVL(S.SQL_ID, ' ') LIKE BI.SQL_ID 
)
SELECT
  DECODE(LAG(SAMPLE_TIME, 1) OVER (ORDER BY RN), SAMPLE_TIME, NULL, 
    TO_CHAR(SAMPLE_TIME, 'dd.mm.yyyy hh24:mi:ss')) SAMPLE_TIME,
  INST_ID INST, 
  SID, 
  PROGRAM,
  ACTION,
  SQL_ID
FROM 
( SELECT 
    S.SAMPLE_TIME,
    LPAD(' ', 2 * (LEVEL - 1)) || S.SESSION_ID SID, 
    TO_CHAR(S.INSTANCE_NUMBER, 990) INST_ID,
    S.PROGRAM,
    S.ACTION,
    S.SQL_ID,
    ROWNUM RN
  FROM
    ALL_RELEVANT_SESSIONS S,
    RELEVANT_SAMPLE_TIMES T
  WHERE
    S.SAMPLE_ID = T.SAMPLE_ID
  CONNECT BY 
    PRIOR S.SAMPLE_ID = S.SAMPLE_ID AND
    PRIOR S.INSTANCE_NUMBER = S.QC_INSTANCE_ID AND
    PRIOR S.SESSION_ID = S.QC_SESSION_ID
  START WITH
    S.QC_SESSION_ID IS NULL
) S
ORDER BY
  S.SAMPLE_TIME DESC,
  RN
));

